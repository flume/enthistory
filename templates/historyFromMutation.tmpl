{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "historyFromMutation" }}
// Code generated by enthistory, DO NOT EDIT.
{{ $pkg := base $.Config.Package }}
{{ template "header" $ }}

{{ $deps := list }}{{ with $.Config.Annotations }}{{ $deps = $.Config.Annotations.Dependencies }}{{ end }}


import (
        "context"
        "errors"
        "fmt"
        {{- range $n := $.Nodes }}
            {{- if and $n.ID (ne $n.ID.Type nil) }}
            {{- if eq $n.ID.Type.String "string" }}
                "strings"
                {{- break }}
            {{- end }}
            {{- end }}
        {{- end }}
        "time"

        "entgo.io/ent"

        "github.com/flume/enthistory"

    {{ range $n := $.Nodes }}
        {{- if and $n.ID (ne $n.ID.Type nil) }}
        {{ if eq $n.ID.Type.String "uuid.UUID" }}
            "github.com/google/uuid"
            {{- break }}
        {{- end }}
        {{- end }}
    {{- end }}
    )

    var (
        idNotFoundError = errors.New("could not get id from mutation")
    )
    func EntOpToHistoryOp(op ent.Op) enthistory.OpType {
    	switch op {
    	case ent.OpDelete, ent.OpDeleteOne:
    		return enthistory.OpTypeDelete
    	case ent.OpUpdate, ent.OpUpdateOne:
    		return enthistory.OpTypeUpdate
    	default:
    		return enthistory.OpTypeInsert
    	}
    }

    func rollback(tx *Tx, err error) error {
    	if tx != nil {
    		if rerr := tx.Rollback(); rerr != nil {
    			err = fmt.Errorf("%w: %v", err, rerr)
    		}
    		return err
    	}
    	return err
    }

{{ range $n := $.Nodes }}
    {{- if and $n.ID (ne $n.ID.Type nil) }}
    {{ if eq $n.ID.Type.String "string" }}
        func genHistoryId(id string, op ent.Op, now time.Time) string {
            return fmt.Sprintf("%s-%s-%d", id, strings.ToLower(EntOpToHistoryOp(op).String()), time.Now().UnixNano())
        }
        {{- break }}
    {{- end }}
    {{- end }}
{{- end }}

    {{ $updatedByKey := extractUpdatedByKey $.Annotations.HistoryConfig.UpdatedBy }}
    {{ $updatedByValueType := extractUpdatedByValueType $.Annotations.HistoryConfig.UpdatedBy }}
	{{ range $n := $.Nodes }}
	    {{ $name := $n.Name }}
	    {{ $history := hasSuffix $name "History" }}
	    {{ if $history }}
	    {{ else }}
		    {{ $mutator := $n.MutationName }}
            {{ range $h := $.Nodes }}
                {{ $sameNodeType := hasPrefix $h.Name (printf "%sHistory" $name) }}
                {{ if $sameNodeType }}
                    func (m *{{ $mutator }}) CreateHistoryFromCreate(ctx context.Context) error {
                        client := m.Client()
                        tx, err := m.Tx()
                        if err != nil {
                            tx = nil
                        }

                       {{ if not (eq $updatedByKey "") }}
                       updatedBy, _ := ctx.Value("{{ $updatedByKey }}").({{ $updatedByValueType }})
                       {{ end }}

                        id, ok := m.ID()
                        if !ok {
                            return rollback(tx, idNotFoundError)
                        }

                        create := client.{{$h.Name}}.Create()
                        if tx != nil {
                            create = tx.{{$h.Name}}.Create()
                        }

                        create = create.
                            SetOperation(EntOpToHistoryOp(m.Op())).
                            SetHistoryTime(time.Now()).
                            SetRef(id)

                        {{- if not (eq $updatedByKey "") }}
                            {{- if (eq $updatedByValueType "int") }}
                            if updatedBy != 0 {
                            {{- end }}
                            {{- if (eq $updatedByValueType "string") }}
                            if updatedBy != "" {
                            {{- end }}
                            {{- if (eq $updatedByValueType "uuid.UUID") }}
                            if updatedBy != uuid.Nil {
                            {{- end }}
                                create = create.SetUpdatedBy(updatedBy)
                            }
                        {{- end }}

                        {{ range $f := $n.Fields }}
                            {{ if (fieldInNode $h $f.Name) }}
                            if {{ camel $f.Name }}, exists := m.{{ $f.StructField }}(); exists {
                                create = create.Set{{ if $f.Nillable }}Nillable{{ end }}{{ $f.StructField }}({{ if $f.Nillable }}&{{ end }}{{ camel $f.Name }})
                            }
                            {{ end }}
                        {{ end }}
                        _, err = create.Save(ctx)
                        if err != nil {
                            rollback(tx, err)
                        }
                        return nil
                    }

                    func (m *{{ $mutator }}) CreateHistoryFromUpdate(ctx context.Context) error {
                        client := m.Client()
                        tx, err := m.Tx()
                        if err != nil {
                            tx = nil
                        }

                        {{ if not (eq $updatedByKey "") }}
                        updatedBy, _ := ctx.Value("{{ $updatedByKey }}").({{ $updatedByValueType }})
                        {{ end }}

                        ids, err := m.IDs(ctx)
                        if err != nil {
                            return rollback(tx, fmt.Errorf("getting ids: %w", err))
                        }

                        for _, id := range ids {
                            {{ camel $name }}, err := client.{{ $name }}.Get(ctx, id)
                            if err != nil {
                                return rollback(tx, err)
                            }

                            create := client.{{$h.Name}}.Create()
                            if tx != nil {
                                create = tx.{{$h.Name}}.Create()
                            }

                            create = create.
                                SetOperation(EntOpToHistoryOp(m.Op())).
                                SetHistoryTime(time.Now()).
                                SetRef(id)

                            {{- if not (eq $updatedByKey "") }}
                                {{- if (eq $updatedByValueType "int") }}
                                if updatedBy != 0 {
                                {{- end }}
                                {{- if (eq $updatedByValueType "string") }}
                                if updatedBy != "" {
                                {{- end }}
                                {{- if (eq $updatedByValueType "uuid.UUID") }}
                                if updatedBy != uuid.Nil {
                                {{- end }}
                                    create = create.SetUpdatedBy(updatedBy)
                                }
                            {{- end }}

                        {{ range $f := $n.Fields }}
                            {{ if (fieldInNode $h $f.Name) }}
                            if {{ camel $f.Name }}, exists := m.{{ $f.StructField }}(); exists {
                                create = create.Set{{ if $f.Nillable }}Nillable{{ end }}{{ $f.StructField }}({{ if $f.Nillable }}&{{ end }}{{ camel $f.Name }})
                            } else{{ if $f.Nillable }} if !m.{{ $f.StructField }}Cleared() {{ end }} {
                                create = create.Set{{ if $f.Nillable }}Nillable{{ end }}{{ $f.StructField }}({{ camel $name }}.{{ pascal $f.Name }})
                            }
                            {{ end }}
                        {{ end }}
                            _, err = create.Save(ctx)
                            if err != nil {
                                rollback(tx, err)
                            }
                        }

                        return nil
                    }

                    func (m *{{ $mutator }}) CreateHistoryFromDelete(ctx context.Context) error {
                        client := m.Client()
                        tx, err := m.Tx()
                        if err != nil {
                            tx = nil
                        }

                        {{ if not (eq $updatedByKey "") }}
                        updatedBy, _ := ctx.Value("{{ $updatedByKey }}").({{ $updatedByValueType }})
                        {{ end }}

                        ids, err := m.IDs(ctx)
                        if err != nil {
                            return rollback(tx, fmt.Errorf("getting ids: %w", err))
                        }

                        for _, id := range ids {
                            {{ camel $name }}, err := client.{{ $name }}.Get(ctx, id)
                            if err != nil {
                                return rollback(tx, err)
                            }

                            create := client.{{$h.Name}}.Create()
                            if tx != nil {
                                create = tx.{{$h.Name}}.Create()
                            }

                            {{- if not (eq $updatedByKey "") }}
                                {{- if (eq $updatedByValueType "int") }}
                                if updatedBy != 0 {
                                {{- end }}
                                {{- if (eq $updatedByValueType "string") }}
                                if updatedBy != "" {
                                {{- end }}
                                {{- if (eq $updatedByValueType "uuid.UUID") }}
                                if updatedBy != uuid.Nil {
                                {{- end }}
                                    create = create.SetUpdatedBy(updatedBy)
                                }
                            {{- end }}

                            _, err = create.
                                SetOperation(EntOpToHistoryOp(m.Op())).
                                SetHistoryTime(time.Now()).
                                SetRef(id).
                            {{- range $f := $n.Fields }}
                                {{ if (fieldInNode $h $f.Name) }}
                                Set{{ if $f.Nillable }}Nillable{{ end }}{{ $f.StructField }}({{ camel $name }}.{{ pascal $f.Name }}).
                                {{- end }}
                            {{- end }}
                                Save(ctx)
                            if err != nil {
                                rollback(tx, err)
                            }
                        }

                        return nil
                    }
                {{ end }}
            {{ end }}
        {{ end }}
	{{ end }}
{{ end }}
