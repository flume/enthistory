{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "auditing" }}
// Code generated by enthistory, DO NOT EDIT.
	{{- $pkg := base $.Config.Package }}
	{{- template "header" $ }}
import (
    "context"
    "encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/flume/enthistory"

    {{- range $n := $.Nodes }}
        {{- $name := $n.Name }}
        {{- $history := hasSuffix $name "History" }}
        {{- if $history }}
        "{{ $.Config.Package }}/{{ lower $n.Name }}"
        {{- end }}
    {{- end }}
)

{{ $updatedByKey := extractUpdatedByKey $.Annotations.HistoryConfig.UpdatedBy }}
{{ $updatedByValueType := extractUpdatedByValueType $.Annotations.HistoryConfig.UpdatedBy }}

type Change struct {
    FieldName string
    Old       any
    New       any
}

func NewChange(fieldName string, old, new any) Change {
    return Change{
        FieldName: fieldName,
        Old:       old,
        New:       new,
    }
}

type HistoryDiff[T any] struct {
    Old     *T
    New     *T
    Changes []Change
}

var (
    MismatchedRefError = errors.New("cannot take diff of histories with different Refs")
    IdenticalHistoryError = errors.New("cannot take diff of identical history")
)

	{{ range $n := $.Nodes }}
	    {{ $name := $n.Name }}

	    {{ $history := hasSuffix $name "History" }}
	    {{ if $history }}
	    {{ else }}
            {{ range $h := $.Nodes }}
                {{ $sameNodeType := hasPrefix $h.Name (printf "%sHistory" $n.Name) }}
                {{ if $sameNodeType }}
func ({{ $h.Receiver }} *{{ $h.Name }}) changes(new *{{ $h.Name }}) []Change {
    var changes []Change
{{- range $f := $h.Fields }}
    {{- if not (in $f.StructField (slist "Ref" "HistoryTime" "Operation" "UpdatedBy")) }}
        if !reflect.DeepEqual({{ $h.Receiver }}.{{ $f.StructField }}, new.{{ $f.StructField }}) {
            changes = append(changes, NewChange({{ lower $h.Name }}.Field{{ $f.StructField }} , {{ $h.Receiver }}.{{ $f.StructField }}, new.{{ $f.StructField }}))
        }
    {{- end }}
{{- end }}
    return changes
}

func ({{ $h.Receiver }} *{{ $h.Name }}) Diff(history *{{ $h.Name }}) (*HistoryDiff[{{ $h.Name }}], error) {
    if {{ $h.Receiver }}.Ref != history.Ref {
        return nil, MismatchedRefError
    }

    {{ $h.Receiver }}Unix, historyUnix := {{ $h.Receiver }}.HistoryTime.Unix(), history.HistoryTime.Unix()
    {{ $h.Receiver }}Older := {{ $h.Receiver }}Unix < historyUnix || ({{ $h.Receiver }}Unix == historyUnix && {{ $h.Receiver }}.ID < history.ID)
    historyOlder := {{ $h.Receiver }}Unix > historyUnix || ({{ $h.Receiver }}Unix == historyUnix && {{ $h.Receiver }}.ID > history.ID)

   if {{ $h.Receiver }}Older {
        return &HistoryDiff[{{ $h.Name }}]{
            Old:     {{ $h.Receiver }},
            New:     history,
            Changes: {{ $h.Receiver }}.changes(history),
        }, nil
    } else if historyOlder {
        return &HistoryDiff[{{ $h.Name }}]{
            Old:     history,
            New:     {{ $h.Receiver }},
            Changes: history.changes({{ $h.Receiver }}),
        }, nil
    }
    return nil, IdenticalHistoryError
}
                {{ end }}
            {{ end }}
        {{ end }}
	{{ end }}

func (c Change) String(op enthistory.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%#v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%#v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case enthistory.OpTypeInsert:
		return fmt.Sprintf("%s: %#s", c.FieldName, newstr)
	case enthistory.OpTypeDelete:
		return fmt.Sprintf("%s: %#s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %#s -> %#s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context) ([][]string, error) {
	records := [][]string{
		{"Table", "Ref Id", "History Time", "Operation", "Changes"{{ if not (eq $updatedByKey "") }}, "Updated By" {{ end }}},
	}
	var rec [][]string
	var err error

	{{- range $n := $.Nodes }}
    {{- if (hasSuffix $n.Name "History") }}
	rec, err = audit{{ $n.Name }}(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, rec...)
    {{ end }}
	{{- end }}

	return records, nil
}

type record struct {
	Table       string
	RefId       any
	HistoryTime time.Time
	Operation   enthistory.OpType
	Changes     []Change
	{{- if not (eq $updatedByKey "") }}
	UpdatedBy   *{{ $updatedByValueType }}
	{{- end }}
}

func (r *record) toRow() []string {
    {{- if not (eq $updatedByKey "") }}
	row := make([]string, 6)
    {{- else }}
    row := make([]string, 5)
    {{- end }}

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefId)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	{{- if not (eq $updatedByKey "") }}
	if r.UpdatedBy != nil {
        row[5] = fmt.Sprintf("%v", *r.UpdatedBy)
    }
	{{- end }}
	return row
}

{{- range $n := $.Nodes }}
{{- if (hasSuffix $n.Name "History") }}

{{- range $h := $.Nodes }}
{{ $sameNodeType := hasPrefix $n.Name (printf "%sHistory" $h.Name) }}
{{- if $sameNodeType }}
type {{ lower $n.Name }}ref struct {
	Ref {{ $h.ID.Type }}
}
{{- end }}
{{- end }}

func audit{{ $n.Name }}(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []{{ lower $n.Name }}ref
	client := New{{ $n.Name }}Client(config)
	err := client.Query().
		Unique(true).
		Order({{ lower $n.Name }}.ByHistoryTime()).
		Select({{ lower $n.Name }}.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where({{ lower $n.Name }}.Ref(currRef.Ref)).
			Order({{ lower $n.Name }}.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			record := record{
				Table:       "{{ $n.Name }}",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
				{{- if not (eq $updatedByKey "") }}
				UpdatedBy:   curr.UpdatedBy,
                {{- end }}
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				record.Changes = (&{{ $n.Name }}{}).changes(curr)
			case enthistory.OpTypeDelete:
				record.Changes = curr.changes(&{{ $n.Name }}{})
			default:
				if i == 0 {
					record.Changes = (&{{ $n.Name }}{}).changes(curr)
				} else {
					record.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, record.toRow())
		}
	}
	return records, nil
}

{{- end }}
{{- end }}
{{ end }}
