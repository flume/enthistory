// Code generated by enthistory, DO NOT EDIT.
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"time"

	"_examples/without_updatedby/ent/characterhistory"
	"_examples/without_updatedby/ent/friendshiphistory"
	"_examples/without_updatedby/ent/residencehistory"

	"github.com/google/uuid"

	"github.com/flume/enthistory"
)

type Change struct {
	FieldName string
	Old       any
	New       any
}

func NewChange(fieldName string, old, new any) Change {
	return Change{
		FieldName: fieldName,
		Old:       old,
		New:       new,
	}
}

type HistoryDiff[T any] struct {
	Old     *T
	New     *T
	Changes []Change
}

var (
	MismatchedRefError = errors.New("cannot take diff of histories with different Refs")
)

func (_m *CharacterHistory) changes(new *CharacterHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(characterhistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(characterhistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.Age, new.Age) {
		changes = append(changes, NewChange(characterhistory.FieldAge, _m.Age, new.Age))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(characterhistory.FieldName, _m.Name, new.Name))
	}
	if !reflect.DeepEqual(_m.Nicknames, new.Nicknames) {
		changes = append(changes, NewChange(characterhistory.FieldNicknames, _m.Nicknames, new.Nicknames))
	}
	if !reflect.DeepEqual(_m.Info, new.Info) {
		changes = append(changes, NewChange(characterhistory.FieldInfo, _m.Info, new.Info))
	}
	return changes
}

func (_m *CharacterHistory) Diff(history *CharacterHistory) (*HistoryDiff[CharacterHistory], error) {
	if _m.Ref != history.Ref {
		return nil, MismatchedRefError
	}
	if _m.HistoryTime.UnixMilli() > history.HistoryTime.UnixMilli() || (_m.HistoryTime.UnixMilli() == history.HistoryTime.UnixMilli() && _m.ID > history.ID) {
		return &HistoryDiff[CharacterHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return &HistoryDiff[CharacterHistory]{
		Old:     _m,
		New:     history,
		Changes: _m.changes(history),
	}, nil
}

func (_m *FriendshipHistory) changes(new *FriendshipHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(friendshiphistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(friendshiphistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.CharacterID, new.CharacterID) {
		changes = append(changes, NewChange(friendshiphistory.FieldCharacterID, _m.CharacterID, new.CharacterID))
	}
	if !reflect.DeepEqual(_m.FriendID, new.FriendID) {
		changes = append(changes, NewChange(friendshiphistory.FieldFriendID, _m.FriendID, new.FriendID))
	}
	return changes
}

func (_m *FriendshipHistory) Diff(history *FriendshipHistory) (*HistoryDiff[FriendshipHistory], error) {
	if _m.Ref != history.Ref {
		return nil, MismatchedRefError
	}
	if _m.HistoryTime.UnixMilli() > history.HistoryTime.UnixMilli() || (_m.HistoryTime.UnixMilli() == history.HistoryTime.UnixMilli() && _m.ID > history.ID) {
		return &HistoryDiff[FriendshipHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return &HistoryDiff[FriendshipHistory]{
		Old:     _m,
		New:     history,
		Changes: _m.changes(history),
	}, nil
}

func (_m *ResidenceHistory) changes(new *ResidenceHistory) []Change {
	var changes []Change
	if !reflect.DeepEqual(_m.CreatedAt, new.CreatedAt) {
		changes = append(changes, NewChange(residencehistory.FieldCreatedAt, _m.CreatedAt, new.CreatedAt))
	}
	if !reflect.DeepEqual(_m.UpdatedAt, new.UpdatedAt) {
		changes = append(changes, NewChange(residencehistory.FieldUpdatedAt, _m.UpdatedAt, new.UpdatedAt))
	}
	if !reflect.DeepEqual(_m.Name, new.Name) {
		changes = append(changes, NewChange(residencehistory.FieldName, _m.Name, new.Name))
	}
	return changes
}

func (_m *ResidenceHistory) Diff(history *ResidenceHistory) (*HistoryDiff[ResidenceHistory], error) {
	if _m.Ref != history.Ref {
		return nil, MismatchedRefError
	}
	if _m.HistoryTime.UnixMilli() > history.HistoryTime.UnixMilli() || (_m.HistoryTime.UnixMilli() == history.HistoryTime.UnixMilli() && _m.ID > history.ID) {
		return &HistoryDiff[ResidenceHistory]{
			Old:     history,
			New:     _m,
			Changes: history.changes(_m),
		}, nil
	}
	return &HistoryDiff[ResidenceHistory]{
		Old:     _m,
		New:     history,
		Changes: _m.changes(history),
	}, nil
}

func (c Change) String(op enthistory.OpType) string {
	var newstr, oldstr string
	if c.New != nil {
		val, err := json.Marshal(c.New)
		if err != nil {
			newstr = fmt.Sprintf("%#v", c.New)
		} else {
			newstr = string(val)
		}
	}
	if c.Old != nil {
		val, err := json.Marshal(c.Old)
		if err != nil {
			oldstr = fmt.Sprintf("%#v", c.Old)
		} else {
			oldstr = string(val)
		}
	}
	switch op {
	case enthistory.OpTypeInsert:
		return fmt.Sprintf("%s: %s", c.FieldName, newstr)
	case enthistory.OpTypeDelete:
		return fmt.Sprintf("%s: %s", c.FieldName, oldstr)
	default:
		return fmt.Sprintf("%s: %s -> %s", c.FieldName, oldstr, newstr)
	}
}

func (c *Client) Audit(ctx context.Context) ([][]string, error) {
	records := [][]string{
		{"Table", "Ref Id", "History Time", "Operation", "Changes"},
	}
	var rec [][]string
	var err error
	rec, err = auditCharacterHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, rec...)

	rec, err = auditFriendshipHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, rec...)

	rec, err = auditResidenceHistory(ctx, c.config)
	if err != nil {
		return nil, err
	}
	records = append(records, rec...)

	return records, nil
}

type record struct {
	Table       string
	RefId       any
	HistoryTime time.Time
	Operation   enthistory.OpType
	Changes     []Change
}

func (r *record) toRow() []string {
	row := make([]string, 5)

	row[0] = r.Table
	row[1] = fmt.Sprintf("%v", r.RefId)
	row[2] = r.HistoryTime.Format(time.ANSIC)
	row[3] = r.Operation.String()
	for i, change := range r.Changes {
		if i == 0 {
			row[4] = change.String(r.Operation)
			continue
		}
		row[4] = fmt.Sprintf("%s\n%s", row[4], change.String(r.Operation))
	}
	return row
}

type characterhistoryref struct {
	Ref int
}

func auditCharacterHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []characterhistoryref
	client := NewCharacterHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(characterhistory.ByHistoryTime()).
		Select(characterhistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(characterhistory.Ref(currRef.Ref)).
			Order(characterhistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			r := record{
				Table:       "CharacterHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				r.Changes = (&CharacterHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				r.Changes = curr.changes(&CharacterHistory{})
			default:
				if i == 0 {
					r.Changes = (&CharacterHistory{}).changes(curr)
				} else {
					r.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, r.toRow())
		}
	}
	return records, nil
}

type friendshiphistoryref struct {
	Ref string
}

func auditFriendshipHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []friendshiphistoryref
	client := NewFriendshipHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(friendshiphistory.ByHistoryTime()).
		Select(friendshiphistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(friendshiphistory.Ref(currRef.Ref)).
			Order(friendshiphistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			r := record{
				Table:       "FriendshipHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				r.Changes = (&FriendshipHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				r.Changes = curr.changes(&FriendshipHistory{})
			default:
				if i == 0 {
					r.Changes = (&FriendshipHistory{}).changes(curr)
				} else {
					r.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, r.toRow())
		}
	}
	return records, nil
}

type residencehistoryref struct {
	Ref uuid.UUID
}

func auditResidenceHistory(ctx context.Context, config config) ([][]string, error) {
	var records = [][]string{}
	var refs []residencehistoryref
	client := NewResidenceHistoryClient(config)
	err := client.Query().
		Unique(true).
		Order(residencehistory.ByHistoryTime()).
		Select(residencehistory.FieldRef).
		Scan(ctx, &refs)

	if err != nil {
		return nil, err
	}
	for _, currRef := range refs {
		histories, err := client.Query().
			Where(residencehistory.Ref(currRef.Ref)).
			Order(residencehistory.ByHistoryTime()).
			All(ctx)
		if err != nil {
			return nil, err
		}

		for i := 0; i < len(histories); i++ {
			curr := histories[i]
			r := record{
				Table:       "ResidenceHistory",
				RefId:       curr.Ref,
				HistoryTime: curr.HistoryTime,
				Operation:   curr.Operation,
			}
			switch curr.Operation {
			case enthistory.OpTypeInsert:
				r.Changes = (&ResidenceHistory{}).changes(curr)
			case enthistory.OpTypeDelete:
				r.Changes = curr.changes(&ResidenceHistory{})
			default:
				if i == 0 {
					r.Changes = (&ResidenceHistory{}).changes(curr)
				} else {
					r.Changes = histories[i-1].changes(curr)
				}
			}
			records = append(records, r.toRow())
		}
	}
	return records, nil
}
