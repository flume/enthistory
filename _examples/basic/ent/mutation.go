// Code generated by ent, DO NOT EDIT.

package ent

import (
	"_examples/basic/ent/character"
	"_examples/basic/ent/characterhistory"
	"_examples/basic/ent/friendship"
	"_examples/basic/ent/friendshiphistory"
	"_examples/basic/ent/predicate"
	"_examples/basic/ent/residence"
	"_examples/basic/ent/residencehistory"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"

	"github.com/flume/enthistory"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCharacter         = "Character"
	TypeCharacterHistory  = "CharacterHistory"
	TypeFriendship        = "Friendship"
	TypeFriendshipHistory = "FriendshipHistory"
	TypeResidence         = "Residence"
	TypeResidenceHistory  = "ResidenceHistory"
)

// CharacterMutation represents an operation that mutates the Character nodes in the graph.
type CharacterMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	age                *int
	addage             *int
	name               *string
	nicknames          *[]string
	appendnicknames    []string
	info               *map[string]interface{}
	level              *int
	addlevel           *int
	clearedFields      map[string]struct{}
	friends            map[int]struct{}
	removedfriends     map[int]struct{}
	clearedfriends     bool
	residence          *uuid.UUID
	clearedresidence   bool
	friendships        map[string]struct{}
	removedfriendships map[string]struct{}
	clearedfriendships bool
	done               bool
	oldValue           func(context.Context) (*Character, error)
	predicates         []predicate.Character
}

var _ ent.Mutation = (*CharacterMutation)(nil)

// characterOption allows management of the mutation configuration using functional options.
type characterOption func(*CharacterMutation)

// newCharacterMutation creates new mutation for the Character entity.
func newCharacterMutation(c config, op Op, opts ...characterOption) *CharacterMutation {
	m := &CharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterID sets the ID field of the mutation.
func withCharacterID(id int) characterOption {
	return func(m *CharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *Character
		)
		m.oldValue = func(ctx context.Context) (*Character, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Character.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacter sets the old Character of the mutation.
func withCharacter(node *Character) characterOption {
	return func(m *CharacterMutation) {
		m.oldValue = func(context.Context) (*Character, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Character.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CharacterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CharacterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CharacterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CharacterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CharacterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CharacterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAge sets the "age" field.
func (m *CharacterMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *CharacterMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *CharacterMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *CharacterMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *CharacterMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetName sets the "name" field.
func (m *CharacterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharacterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharacterMutation) ResetName() {
	m.name = nil
}

// SetNicknames sets the "nicknames" field.
func (m *CharacterMutation) SetNicknames(s []string) {
	m.nicknames = &s
	m.appendnicknames = nil
}

// Nicknames returns the value of the "nicknames" field in the mutation.
func (m *CharacterMutation) Nicknames() (r []string, exists bool) {
	v := m.nicknames
	if v == nil {
		return
	}
	return *v, true
}

// OldNicknames returns the old "nicknames" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldNicknames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNicknames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNicknames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNicknames: %w", err)
	}
	return oldValue.Nicknames, nil
}

// AppendNicknames adds s to the "nicknames" field.
func (m *CharacterMutation) AppendNicknames(s []string) {
	m.appendnicknames = append(m.appendnicknames, s...)
}

// AppendedNicknames returns the list of values that were appended to the "nicknames" field in this mutation.
func (m *CharacterMutation) AppendedNicknames() ([]string, bool) {
	if len(m.appendnicknames) == 0 {
		return nil, false
	}
	return m.appendnicknames, true
}

// ClearNicknames clears the value of the "nicknames" field.
func (m *CharacterMutation) ClearNicknames() {
	m.nicknames = nil
	m.appendnicknames = nil
	m.clearedFields[character.FieldNicknames] = struct{}{}
}

// NicknamesCleared returns if the "nicknames" field was cleared in this mutation.
func (m *CharacterMutation) NicknamesCleared() bool {
	_, ok := m.clearedFields[character.FieldNicknames]
	return ok
}

// ResetNicknames resets all changes to the "nicknames" field.
func (m *CharacterMutation) ResetNicknames() {
	m.nicknames = nil
	m.appendnicknames = nil
	delete(m.clearedFields, character.FieldNicknames)
}

// SetInfo sets the "info" field.
func (m *CharacterMutation) SetInfo(value map[string]interface{}) {
	m.info = &value
}

// Info returns the value of the "info" field in the mutation.
func (m *CharacterMutation) Info() (r map[string]interface{}, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ClearInfo clears the value of the "info" field.
func (m *CharacterMutation) ClearInfo() {
	m.info = nil
	m.clearedFields[character.FieldInfo] = struct{}{}
}

// InfoCleared returns if the "info" field was cleared in this mutation.
func (m *CharacterMutation) InfoCleared() bool {
	_, ok := m.clearedFields[character.FieldInfo]
	return ok
}

// ResetInfo resets all changes to the "info" field.
func (m *CharacterMutation) ResetInfo() {
	m.info = nil
	delete(m.clearedFields, character.FieldInfo)
}

// SetLevel sets the "level" field.
func (m *CharacterMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CharacterMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLevel(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CharacterMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CharacterMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *CharacterMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[character.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *CharacterMutation) LevelCleared() bool {
	_, ok := m.clearedFields[character.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *CharacterMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, character.FieldLevel)
}

// AddFriendIDs adds the "friends" edge to the Character entity by ids.
func (m *CharacterMutation) AddFriendIDs(ids ...int) {
	if m.friends == nil {
		m.friends = make(map[int]struct{})
	}
	for i := range ids {
		m.friends[ids[i]] = struct{}{}
	}
}

// ClearFriends clears the "friends" edge to the Character entity.
func (m *CharacterMutation) ClearFriends() {
	m.clearedfriends = true
}

// FriendsCleared reports if the "friends" edge to the Character entity was cleared.
func (m *CharacterMutation) FriendsCleared() bool {
	return m.clearedfriends
}

// RemoveFriendIDs removes the "friends" edge to the Character entity by IDs.
func (m *CharacterMutation) RemoveFriendIDs(ids ...int) {
	if m.removedfriends == nil {
		m.removedfriends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.friends, ids[i])
		m.removedfriends[ids[i]] = struct{}{}
	}
}

// RemovedFriends returns the removed IDs of the "friends" edge to the Character entity.
func (m *CharacterMutation) RemovedFriendsIDs() (ids []int) {
	for id := range m.removedfriends {
		ids = append(ids, id)
	}
	return
}

// FriendsIDs returns the "friends" edge IDs in the mutation.
func (m *CharacterMutation) FriendsIDs() (ids []int) {
	for id := range m.friends {
		ids = append(ids, id)
	}
	return
}

// ResetFriends resets all changes to the "friends" edge.
func (m *CharacterMutation) ResetFriends() {
	m.friends = nil
	m.clearedfriends = false
	m.removedfriends = nil
}

// SetResidenceID sets the "residence" edge to the Residence entity by id.
func (m *CharacterMutation) SetResidenceID(id uuid.UUID) {
	m.residence = &id
}

// ClearResidence clears the "residence" edge to the Residence entity.
func (m *CharacterMutation) ClearResidence() {
	m.clearedresidence = true
}

// ResidenceCleared reports if the "residence" edge to the Residence entity was cleared.
func (m *CharacterMutation) ResidenceCleared() bool {
	return m.clearedresidence
}

// ResidenceID returns the "residence" edge ID in the mutation.
func (m *CharacterMutation) ResidenceID() (id uuid.UUID, exists bool) {
	if m.residence != nil {
		return *m.residence, true
	}
	return
}

// ResidenceIDs returns the "residence" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResidenceID instead. It exists only for internal usage by the builders.
func (m *CharacterMutation) ResidenceIDs() (ids []uuid.UUID) {
	if id := m.residence; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResidence resets all changes to the "residence" edge.
func (m *CharacterMutation) ResetResidence() {
	m.residence = nil
	m.clearedresidence = false
}

// AddFriendshipIDs adds the "friendships" edge to the Friendship entity by ids.
func (m *CharacterMutation) AddFriendshipIDs(ids ...string) {
	if m.friendships == nil {
		m.friendships = make(map[string]struct{})
	}
	for i := range ids {
		m.friendships[ids[i]] = struct{}{}
	}
}

// ClearFriendships clears the "friendships" edge to the Friendship entity.
func (m *CharacterMutation) ClearFriendships() {
	m.clearedfriendships = true
}

// FriendshipsCleared reports if the "friendships" edge to the Friendship entity was cleared.
func (m *CharacterMutation) FriendshipsCleared() bool {
	return m.clearedfriendships
}

// RemoveFriendshipIDs removes the "friendships" edge to the Friendship entity by IDs.
func (m *CharacterMutation) RemoveFriendshipIDs(ids ...string) {
	if m.removedfriendships == nil {
		m.removedfriendships = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.friendships, ids[i])
		m.removedfriendships[ids[i]] = struct{}{}
	}
}

// RemovedFriendships returns the removed IDs of the "friendships" edge to the Friendship entity.
func (m *CharacterMutation) RemovedFriendshipsIDs() (ids []string) {
	for id := range m.removedfriendships {
		ids = append(ids, id)
	}
	return
}

// FriendshipsIDs returns the "friendships" edge IDs in the mutation.
func (m *CharacterMutation) FriendshipsIDs() (ids []string) {
	for id := range m.friendships {
		ids = append(ids, id)
	}
	return
}

// ResetFriendships resets all changes to the "friendships" edge.
func (m *CharacterMutation) ResetFriendships() {
	m.friendships = nil
	m.clearedfriendships = false
	m.removedfriendships = nil
}

// Where appends a list predicates to the CharacterMutation builder.
func (m *CharacterMutation) Where(ps ...predicate.Character) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Character, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Character).
func (m *CharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, character.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, character.FieldUpdatedAt)
	}
	if m.age != nil {
		fields = append(fields, character.FieldAge)
	}
	if m.name != nil {
		fields = append(fields, character.FieldName)
	}
	if m.nicknames != nil {
		fields = append(fields, character.FieldNicknames)
	}
	if m.info != nil {
		fields = append(fields, character.FieldInfo)
	}
	if m.level != nil {
		fields = append(fields, character.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case character.FieldCreatedAt:
		return m.CreatedAt()
	case character.FieldUpdatedAt:
		return m.UpdatedAt()
	case character.FieldAge:
		return m.Age()
	case character.FieldName:
		return m.Name()
	case character.FieldNicknames:
		return m.Nicknames()
	case character.FieldInfo:
		return m.Info()
	case character.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case character.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case character.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case character.FieldAge:
		return m.OldAge(ctx)
	case character.FieldName:
		return m.OldName(ctx)
	case character.FieldNicknames:
		return m.OldNicknames(ctx)
	case character.FieldInfo:
		return m.OldInfo(ctx)
	case character.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Character field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case character.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case character.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case character.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case character.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case character.FieldNicknames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNicknames(v)
		return nil
	case character.FieldInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case character.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, character.FieldAge)
	}
	if m.addlevel != nil {
		fields = append(fields, character.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case character.FieldAge:
		return m.AddedAge()
	case character.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case character.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case character.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Character numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(character.FieldNicknames) {
		fields = append(fields, character.FieldNicknames)
	}
	if m.FieldCleared(character.FieldInfo) {
		fields = append(fields, character.FieldInfo)
	}
	if m.FieldCleared(character.FieldLevel) {
		fields = append(fields, character.FieldLevel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterMutation) ClearField(name string) error {
	switch name {
	case character.FieldNicknames:
		m.ClearNicknames()
		return nil
	case character.FieldInfo:
		m.ClearInfo()
		return nil
	case character.FieldLevel:
		m.ClearLevel()
		return nil
	}
	return fmt.Errorf("unknown Character nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterMutation) ResetField(name string) error {
	switch name {
	case character.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case character.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case character.FieldAge:
		m.ResetAge()
		return nil
	case character.FieldName:
		m.ResetName()
		return nil
	case character.FieldNicknames:
		m.ResetNicknames()
		return nil
	case character.FieldInfo:
		m.ResetInfo()
		return nil
	case character.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.friends != nil {
		edges = append(edges, character.EdgeFriends)
	}
	if m.residence != nil {
		edges = append(edges, character.EdgeResidence)
	}
	if m.friendships != nil {
		edges = append(edges, character.EdgeFriendships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case character.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.friends))
		for id := range m.friends {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeResidence:
		if id := m.residence; id != nil {
			return []ent.Value{*id}
		}
	case character.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.friendships))
		for id := range m.friendships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfriends != nil {
		edges = append(edges, character.EdgeFriends)
	}
	if m.removedfriendships != nil {
		edges = append(edges, character.EdgeFriendships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case character.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.removedfriends))
		for id := range m.removedfriends {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.removedfriendships))
		for id := range m.removedfriendships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfriends {
		edges = append(edges, character.EdgeFriends)
	}
	if m.clearedresidence {
		edges = append(edges, character.EdgeResidence)
	}
	if m.clearedfriendships {
		edges = append(edges, character.EdgeFriendships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterMutation) EdgeCleared(name string) bool {
	switch name {
	case character.EdgeFriends:
		return m.clearedfriends
	case character.EdgeResidence:
		return m.clearedresidence
	case character.EdgeFriendships:
		return m.clearedfriendships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterMutation) ClearEdge(name string) error {
	switch name {
	case character.EdgeResidence:
		m.ClearResidence()
		return nil
	}
	return fmt.Errorf("unknown Character unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterMutation) ResetEdge(name string) error {
	switch name {
	case character.EdgeFriends:
		m.ResetFriends()
		return nil
	case character.EdgeResidence:
		m.ResetResidence()
		return nil
	case character.EdgeFriendships:
		m.ResetFriendships()
		return nil
	}
	return fmt.Errorf("unknown Character edge %s", name)
}

// CharacterHistoryMutation represents an operation that mutates the CharacterHistory nodes in the graph.
type CharacterHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	history_time    *time.Time
	operation       *enthistory.OpType
	ref             *int
	addref          *int
	updated_by      *int
	addupdated_by   *int
	age             *int
	addage          *int
	name            *string
	nicknames       *[]string
	appendnicknames []string
	info            *map[string]interface{}
	level           *int
	addlevel        *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*CharacterHistory, error)
	predicates      []predicate.CharacterHistory
}

var _ ent.Mutation = (*CharacterHistoryMutation)(nil)

// characterhistoryOption allows management of the mutation configuration using functional options.
type characterhistoryOption func(*CharacterHistoryMutation)

// newCharacterHistoryMutation creates new mutation for the CharacterHistory entity.
func newCharacterHistoryMutation(c config, op Op, opts ...characterhistoryOption) *CharacterHistoryMutation {
	m := &CharacterHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacterHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterHistoryID sets the ID field of the mutation.
func withCharacterHistoryID(id int) characterhistoryOption {
	return func(m *CharacterHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *CharacterHistory
		)
		m.oldValue = func(ctx context.Context) (*CharacterHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CharacterHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacterHistory sets the old CharacterHistory of the mutation.
func withCharacterHistory(node *CharacterHistory) characterhistoryOption {
	return func(m *CharacterHistoryMutation) {
		m.oldValue = func(context.Context) (*CharacterHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CharacterHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CharacterHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CharacterHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CharacterHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CharacterHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CharacterHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CharacterHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHistoryTime sets the "history_time" field.
func (m *CharacterHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *CharacterHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *CharacterHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetOperation sets the "operation" field.
func (m *CharacterHistoryMutation) SetOperation(et enthistory.OpType) {
	m.operation = &et
}

// Operation returns the value of the "operation" field in the mutation.
func (m *CharacterHistoryMutation) Operation() (r enthistory.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldOperation(ctx context.Context) (v enthistory.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *CharacterHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetRef sets the "ref" field.
func (m *CharacterHistoryMutation) SetRef(i int) {
	m.ref = &i
	m.addref = nil
}

// Ref returns the value of the "ref" field in the mutation.
func (m *CharacterHistoryMutation) Ref() (r int, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldRef(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// AddRef adds i to the "ref" field.
func (m *CharacterHistoryMutation) AddRef(i int) {
	if m.addref != nil {
		*m.addref += i
	} else {
		m.addref = &i
	}
}

// AddedRef returns the value that was added to the "ref" field in this mutation.
func (m *CharacterHistoryMutation) AddedRef() (r int, exists bool) {
	v := m.addref
	if v == nil {
		return
	}
	return *v, true
}

// ClearRef clears the value of the "ref" field.
func (m *CharacterHistoryMutation) ClearRef() {
	m.ref = nil
	m.addref = nil
	m.clearedFields[characterhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *CharacterHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[characterhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *CharacterHistoryMutation) ResetRef() {
	m.ref = nil
	m.addref = nil
	delete(m.clearedFields, characterhistory.FieldRef)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CharacterHistoryMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CharacterHistoryMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldUpdatedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *CharacterHistoryMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *CharacterHistoryMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *CharacterHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[characterhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *CharacterHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[characterhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CharacterHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, characterhistory.FieldUpdatedBy)
}

// SetAge sets the "age" field.
func (m *CharacterHistoryMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *CharacterHistoryMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *CharacterHistoryMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *CharacterHistoryMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *CharacterHistoryMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetName sets the "name" field.
func (m *CharacterHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharacterHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharacterHistoryMutation) ResetName() {
	m.name = nil
}

// SetNicknames sets the "nicknames" field.
func (m *CharacterHistoryMutation) SetNicknames(s []string) {
	m.nicknames = &s
	m.appendnicknames = nil
}

// Nicknames returns the value of the "nicknames" field in the mutation.
func (m *CharacterHistoryMutation) Nicknames() (r []string, exists bool) {
	v := m.nicknames
	if v == nil {
		return
	}
	return *v, true
}

// OldNicknames returns the old "nicknames" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldNicknames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNicknames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNicknames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNicknames: %w", err)
	}
	return oldValue.Nicknames, nil
}

// AppendNicknames adds s to the "nicknames" field.
func (m *CharacterHistoryMutation) AppendNicknames(s []string) {
	m.appendnicknames = append(m.appendnicknames, s...)
}

// AppendedNicknames returns the list of values that were appended to the "nicknames" field in this mutation.
func (m *CharacterHistoryMutation) AppendedNicknames() ([]string, bool) {
	if len(m.appendnicknames) == 0 {
		return nil, false
	}
	return m.appendnicknames, true
}

// ClearNicknames clears the value of the "nicknames" field.
func (m *CharacterHistoryMutation) ClearNicknames() {
	m.nicknames = nil
	m.appendnicknames = nil
	m.clearedFields[characterhistory.FieldNicknames] = struct{}{}
}

// NicknamesCleared returns if the "nicknames" field was cleared in this mutation.
func (m *CharacterHistoryMutation) NicknamesCleared() bool {
	_, ok := m.clearedFields[characterhistory.FieldNicknames]
	return ok
}

// ResetNicknames resets all changes to the "nicknames" field.
func (m *CharacterHistoryMutation) ResetNicknames() {
	m.nicknames = nil
	m.appendnicknames = nil
	delete(m.clearedFields, characterhistory.FieldNicknames)
}

// SetInfo sets the "info" field.
func (m *CharacterHistoryMutation) SetInfo(value map[string]interface{}) {
	m.info = &value
}

// Info returns the value of the "info" field in the mutation.
func (m *CharacterHistoryMutation) Info() (r map[string]interface{}, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ClearInfo clears the value of the "info" field.
func (m *CharacterHistoryMutation) ClearInfo() {
	m.info = nil
	m.clearedFields[characterhistory.FieldInfo] = struct{}{}
}

// InfoCleared returns if the "info" field was cleared in this mutation.
func (m *CharacterHistoryMutation) InfoCleared() bool {
	_, ok := m.clearedFields[characterhistory.FieldInfo]
	return ok
}

// ResetInfo resets all changes to the "info" field.
func (m *CharacterHistoryMutation) ResetInfo() {
	m.info = nil
	delete(m.clearedFields, characterhistory.FieldInfo)
}

// SetLevel sets the "level" field.
func (m *CharacterHistoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CharacterHistoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the CharacterHistory entity.
// If the CharacterHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterHistoryMutation) OldLevel(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CharacterHistoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CharacterHistoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *CharacterHistoryMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[characterhistory.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *CharacterHistoryMutation) LevelCleared() bool {
	_, ok := m.clearedFields[characterhistory.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *CharacterHistoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, characterhistory.FieldLevel)
}

// Where appends a list predicates to the CharacterHistoryMutation builder.
func (m *CharacterHistoryMutation) Where(ps ...predicate.CharacterHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CharacterHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CharacterHistory).
func (m *CharacterHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterHistoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, characterhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, characterhistory.FieldUpdatedAt)
	}
	if m.history_time != nil {
		fields = append(fields, characterhistory.FieldHistoryTime)
	}
	if m.operation != nil {
		fields = append(fields, characterhistory.FieldOperation)
	}
	if m.ref != nil {
		fields = append(fields, characterhistory.FieldRef)
	}
	if m.updated_by != nil {
		fields = append(fields, characterhistory.FieldUpdatedBy)
	}
	if m.age != nil {
		fields = append(fields, characterhistory.FieldAge)
	}
	if m.name != nil {
		fields = append(fields, characterhistory.FieldName)
	}
	if m.nicknames != nil {
		fields = append(fields, characterhistory.FieldNicknames)
	}
	if m.info != nil {
		fields = append(fields, characterhistory.FieldInfo)
	}
	if m.level != nil {
		fields = append(fields, characterhistory.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case characterhistory.FieldCreatedAt:
		return m.CreatedAt()
	case characterhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case characterhistory.FieldHistoryTime:
		return m.HistoryTime()
	case characterhistory.FieldOperation:
		return m.Operation()
	case characterhistory.FieldRef:
		return m.Ref()
	case characterhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case characterhistory.FieldAge:
		return m.Age()
	case characterhistory.FieldName:
		return m.Name()
	case characterhistory.FieldNicknames:
		return m.Nicknames()
	case characterhistory.FieldInfo:
		return m.Info()
	case characterhistory.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case characterhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case characterhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case characterhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case characterhistory.FieldOperation:
		return m.OldOperation(ctx)
	case characterhistory.FieldRef:
		return m.OldRef(ctx)
	case characterhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case characterhistory.FieldAge:
		return m.OldAge(ctx)
	case characterhistory.FieldName:
		return m.OldName(ctx)
	case characterhistory.FieldNicknames:
		return m.OldNicknames(ctx)
	case characterhistory.FieldInfo:
		return m.OldInfo(ctx)
	case characterhistory.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown CharacterHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case characterhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case characterhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case characterhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case characterhistory.FieldOperation:
		v, ok := value.(enthistory.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case characterhistory.FieldRef:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case characterhistory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case characterhistory.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case characterhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case characterhistory.FieldNicknames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNicknames(v)
		return nil
	case characterhistory.FieldInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case characterhistory.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addref != nil {
		fields = append(fields, characterhistory.FieldRef)
	}
	if m.addupdated_by != nil {
		fields = append(fields, characterhistory.FieldUpdatedBy)
	}
	if m.addage != nil {
		fields = append(fields, characterhistory.FieldAge)
	}
	if m.addlevel != nil {
		fields = append(fields, characterhistory.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case characterhistory.FieldRef:
		return m.AddedRef()
	case characterhistory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case characterhistory.FieldAge:
		return m.AddedAge()
	case characterhistory.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case characterhistory.FieldRef:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRef(v)
		return nil
	case characterhistory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case characterhistory.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case characterhistory.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(characterhistory.FieldRef) {
		fields = append(fields, characterhistory.FieldRef)
	}
	if m.FieldCleared(characterhistory.FieldUpdatedBy) {
		fields = append(fields, characterhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(characterhistory.FieldNicknames) {
		fields = append(fields, characterhistory.FieldNicknames)
	}
	if m.FieldCleared(characterhistory.FieldInfo) {
		fields = append(fields, characterhistory.FieldInfo)
	}
	if m.FieldCleared(characterhistory.FieldLevel) {
		fields = append(fields, characterhistory.FieldLevel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterHistoryMutation) ClearField(name string) error {
	switch name {
	case characterhistory.FieldRef:
		m.ClearRef()
		return nil
	case characterhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case characterhistory.FieldNicknames:
		m.ClearNicknames()
		return nil
	case characterhistory.FieldInfo:
		m.ClearInfo()
		return nil
	case characterhistory.FieldLevel:
		m.ClearLevel()
		return nil
	}
	return fmt.Errorf("unknown CharacterHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterHistoryMutation) ResetField(name string) error {
	switch name {
	case characterhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case characterhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case characterhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case characterhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case characterhistory.FieldRef:
		m.ResetRef()
		return nil
	case characterhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case characterhistory.FieldAge:
		m.ResetAge()
		return nil
	case characterhistory.FieldName:
		m.ResetName()
		return nil
	case characterhistory.FieldNicknames:
		m.ResetNicknames()
		return nil
	case characterhistory.FieldInfo:
		m.ResetInfo()
		return nil
	case characterhistory.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown CharacterHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CharacterHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CharacterHistory edge %s", name)
}

// FriendshipMutation represents an operation that mutates the Friendship nodes in the graph.
type FriendshipMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	character        *int
	clearedcharacter bool
	friend           *int
	clearedfriend    bool
	done             bool
	oldValue         func(context.Context) (*Friendship, error)
	predicates       []predicate.Friendship
}

var _ ent.Mutation = (*FriendshipMutation)(nil)

// friendshipOption allows management of the mutation configuration using functional options.
type friendshipOption func(*FriendshipMutation)

// newFriendshipMutation creates new mutation for the Friendship entity.
func newFriendshipMutation(c config, op Op, opts ...friendshipOption) *FriendshipMutation {
	m := &FriendshipMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipID sets the ID field of the mutation.
func withFriendshipID(id string) friendshipOption {
	return func(m *FriendshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Friendship
		)
		m.oldValue = func(ctx context.Context) (*Friendship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Friendship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendship sets the old Friendship of the mutation.
func withFriendship(node *Friendship) friendshipOption {
	return func(m *FriendshipMutation) {
		m.oldValue = func(context.Context) (*Friendship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Friendship entities.
func (m *FriendshipMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Friendship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FriendshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FriendshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FriendshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCharacterID sets the "character_id" field.
func (m *FriendshipMutation) SetCharacterID(i int) {
	m.character = &i
}

// CharacterID returns the value of the "character_id" field in the mutation.
func (m *FriendshipMutation) CharacterID() (r int, exists bool) {
	v := m.character
	if v == nil {
		return
	}
	return *v, true
}

// OldCharacterID returns the old "character_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldCharacterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharacterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharacterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharacterID: %w", err)
	}
	return oldValue.CharacterID, nil
}

// ResetCharacterID resets all changes to the "character_id" field.
func (m *FriendshipMutation) ResetCharacterID() {
	m.character = nil
}

// SetFriendID sets the "friend_id" field.
func (m *FriendshipMutation) SetFriendID(i int) {
	m.friend = &i
}

// FriendID returns the value of the "friend_id" field in the mutation.
func (m *FriendshipMutation) FriendID() (r int, exists bool) {
	v := m.friend
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendID returns the old "friend_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldFriendID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendID: %w", err)
	}
	return oldValue.FriendID, nil
}

// ResetFriendID resets all changes to the "friend_id" field.
func (m *FriendshipMutation) ResetFriendID() {
	m.friend = nil
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *FriendshipMutation) ClearCharacter() {
	m.clearedcharacter = true
	m.clearedFields[friendship.FieldCharacterID] = struct{}{}
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *FriendshipMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// CharacterIDs returns the "character" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CharacterID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) CharacterIDs() (ids []int) {
	if id := m.character; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *FriendshipMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
}

// ClearFriend clears the "friend" edge to the Character entity.
func (m *FriendshipMutation) ClearFriend() {
	m.clearedfriend = true
	m.clearedFields[friendship.FieldFriendID] = struct{}{}
}

// FriendCleared reports if the "friend" edge to the Character entity was cleared.
func (m *FriendshipMutation) FriendCleared() bool {
	return m.clearedfriend
}

// FriendIDs returns the "friend" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) FriendIDs() (ids []int) {
	if id := m.friend; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriend resets all changes to the "friend" edge.
func (m *FriendshipMutation) ResetFriend() {
	m.friend = nil
	m.clearedfriend = false
}

// Where appends a list predicates to the FriendshipMutation builder.
func (m *FriendshipMutation) Where(ps ...predicate.Friendship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Friendship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Friendship).
func (m *FriendshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, friendship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, friendship.FieldUpdatedAt)
	}
	if m.character != nil {
		fields = append(fields, friendship.FieldCharacterID)
	}
	if m.friend != nil {
		fields = append(fields, friendship.FieldFriendID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendship.FieldCreatedAt:
		return m.CreatedAt()
	case friendship.FieldUpdatedAt:
		return m.UpdatedAt()
	case friendship.FieldCharacterID:
		return m.CharacterID()
	case friendship.FieldFriendID:
		return m.FriendID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case friendship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case friendship.FieldCharacterID:
		return m.OldCharacterID(ctx)
	case friendship.FieldFriendID:
		return m.OldFriendID(ctx)
	}
	return nil, fmt.Errorf("unknown Friendship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case friendship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case friendship.FieldCharacterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterID(v)
		return nil
	case friendship.FieldFriendID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendID(v)
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Friendship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Friendship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipMutation) ResetField(name string) error {
	switch name {
	case friendship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case friendship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case friendship.FieldCharacterID:
		m.ResetCharacterID()
		return nil
	case friendship.FieldFriendID:
		m.ResetFriendID()
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.character != nil {
		edges = append(edges, friendship.EdgeCharacter)
	}
	if m.friend != nil {
		edges = append(edges, friendship.EdgeFriend)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendship.EdgeCharacter:
		if id := m.character; id != nil {
			return []ent.Value{*id}
		}
	case friendship.EdgeFriend:
		if id := m.friend; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcharacter {
		edges = append(edges, friendship.EdgeCharacter)
	}
	if m.clearedfriend {
		edges = append(edges, friendship.EdgeFriend)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipMutation) EdgeCleared(name string) bool {
	switch name {
	case friendship.EdgeCharacter:
		return m.clearedcharacter
	case friendship.EdgeFriend:
		return m.clearedfriend
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipMutation) ClearEdge(name string) error {
	switch name {
	case friendship.EdgeCharacter:
		m.ClearCharacter()
		return nil
	case friendship.EdgeFriend:
		m.ClearFriend()
		return nil
	}
	return fmt.Errorf("unknown Friendship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipMutation) ResetEdge(name string) error {
	switch name {
	case friendship.EdgeCharacter:
		m.ResetCharacter()
		return nil
	case friendship.EdgeFriend:
		m.ResetFriend()
		return nil
	}
	return fmt.Errorf("unknown Friendship edge %s", name)
}

// FriendshipHistoryMutation represents an operation that mutates the FriendshipHistory nodes in the graph.
type FriendshipHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	history_time    *time.Time
	operation       *enthistory.OpType
	ref             *string
	updated_by      *int
	addupdated_by   *int
	character_id    *int
	addcharacter_id *int
	friend_id       *int
	addfriend_id    *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*FriendshipHistory, error)
	predicates      []predicate.FriendshipHistory
}

var _ ent.Mutation = (*FriendshipHistoryMutation)(nil)

// friendshiphistoryOption allows management of the mutation configuration using functional options.
type friendshiphistoryOption func(*FriendshipHistoryMutation)

// newFriendshipHistoryMutation creates new mutation for the FriendshipHistory entity.
func newFriendshipHistoryMutation(c config, op Op, opts ...friendshiphistoryOption) *FriendshipHistoryMutation {
	m := &FriendshipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendshipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipHistoryID sets the ID field of the mutation.
func withFriendshipHistoryID(id int) friendshiphistoryOption {
	return func(m *FriendshipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendshipHistory
		)
		m.oldValue = func(ctx context.Context) (*FriendshipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendshipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendshipHistory sets the old FriendshipHistory of the mutation.
func withFriendshipHistory(node *FriendshipHistory) friendshiphistoryOption {
	return func(m *FriendshipHistoryMutation) {
		m.oldValue = func(context.Context) (*FriendshipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendshipHistory entities.
func (m *FriendshipHistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendshipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendshipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendshipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendshipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FriendshipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FriendshipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FriendshipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHistoryTime sets the "history_time" field.
func (m *FriendshipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *FriendshipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *FriendshipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetOperation sets the "operation" field.
func (m *FriendshipHistoryMutation) SetOperation(et enthistory.OpType) {
	m.operation = &et
}

// Operation returns the value of the "operation" field in the mutation.
func (m *FriendshipHistoryMutation) Operation() (r enthistory.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldOperation(ctx context.Context) (v enthistory.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *FriendshipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetRef sets the "ref" field.
func (m *FriendshipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *FriendshipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *FriendshipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[friendshiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *FriendshipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[friendshiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *FriendshipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, friendshiphistory.FieldRef)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FriendshipHistoryMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FriendshipHistoryMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldUpdatedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FriendshipHistoryMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FriendshipHistoryMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FriendshipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[friendshiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FriendshipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[friendshiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FriendshipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, friendshiphistory.FieldUpdatedBy)
}

// SetCharacterID sets the "character_id" field.
func (m *FriendshipHistoryMutation) SetCharacterID(i int) {
	m.character_id = &i
	m.addcharacter_id = nil
}

// CharacterID returns the value of the "character_id" field in the mutation.
func (m *FriendshipHistoryMutation) CharacterID() (r int, exists bool) {
	v := m.character_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCharacterID returns the old "character_id" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldCharacterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharacterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharacterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharacterID: %w", err)
	}
	return oldValue.CharacterID, nil
}

// AddCharacterID adds i to the "character_id" field.
func (m *FriendshipHistoryMutation) AddCharacterID(i int) {
	if m.addcharacter_id != nil {
		*m.addcharacter_id += i
	} else {
		m.addcharacter_id = &i
	}
}

// AddedCharacterID returns the value that was added to the "character_id" field in this mutation.
func (m *FriendshipHistoryMutation) AddedCharacterID() (r int, exists bool) {
	v := m.addcharacter_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCharacterID resets all changes to the "character_id" field.
func (m *FriendshipHistoryMutation) ResetCharacterID() {
	m.character_id = nil
	m.addcharacter_id = nil
}

// SetFriendID sets the "friend_id" field.
func (m *FriendshipHistoryMutation) SetFriendID(i int) {
	m.friend_id = &i
	m.addfriend_id = nil
}

// FriendID returns the value of the "friend_id" field in the mutation.
func (m *FriendshipHistoryMutation) FriendID() (r int, exists bool) {
	v := m.friend_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendID returns the old "friend_id" field's value of the FriendshipHistory entity.
// If the FriendshipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipHistoryMutation) OldFriendID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendID: %w", err)
	}
	return oldValue.FriendID, nil
}

// AddFriendID adds i to the "friend_id" field.
func (m *FriendshipHistoryMutation) AddFriendID(i int) {
	if m.addfriend_id != nil {
		*m.addfriend_id += i
	} else {
		m.addfriend_id = &i
	}
}

// AddedFriendID returns the value that was added to the "friend_id" field in this mutation.
func (m *FriendshipHistoryMutation) AddedFriendID() (r int, exists bool) {
	v := m.addfriend_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFriendID resets all changes to the "friend_id" field.
func (m *FriendshipHistoryMutation) ResetFriendID() {
	m.friend_id = nil
	m.addfriend_id = nil
}

// Where appends a list predicates to the FriendshipHistoryMutation builder.
func (m *FriendshipHistoryMutation) Where(ps ...predicate.FriendshipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendshipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendshipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FriendshipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendshipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendshipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FriendshipHistory).
func (m *FriendshipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, friendshiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, friendshiphistory.FieldUpdatedAt)
	}
	if m.history_time != nil {
		fields = append(fields, friendshiphistory.FieldHistoryTime)
	}
	if m.operation != nil {
		fields = append(fields, friendshiphistory.FieldOperation)
	}
	if m.ref != nil {
		fields = append(fields, friendshiphistory.FieldRef)
	}
	if m.updated_by != nil {
		fields = append(fields, friendshiphistory.FieldUpdatedBy)
	}
	if m.character_id != nil {
		fields = append(fields, friendshiphistory.FieldCharacterID)
	}
	if m.friend_id != nil {
		fields = append(fields, friendshiphistory.FieldFriendID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendshiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case friendshiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case friendshiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case friendshiphistory.FieldOperation:
		return m.Operation()
	case friendshiphistory.FieldRef:
		return m.Ref()
	case friendshiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case friendshiphistory.FieldCharacterID:
		return m.CharacterID()
	case friendshiphistory.FieldFriendID:
		return m.FriendID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendshiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case friendshiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case friendshiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case friendshiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case friendshiphistory.FieldRef:
		return m.OldRef(ctx)
	case friendshiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case friendshiphistory.FieldCharacterID:
		return m.OldCharacterID(ctx)
	case friendshiphistory.FieldFriendID:
		return m.OldFriendID(ctx)
	}
	return nil, fmt.Errorf("unknown FriendshipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendshiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case friendshiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case friendshiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case friendshiphistory.FieldOperation:
		v, ok := value.(enthistory.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case friendshiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case friendshiphistory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case friendshiphistory.FieldCharacterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterID(v)
		return nil
	case friendshiphistory.FieldFriendID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendID(v)
		return nil
	}
	return fmt.Errorf("unknown FriendshipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, friendshiphistory.FieldUpdatedBy)
	}
	if m.addcharacter_id != nil {
		fields = append(fields, friendshiphistory.FieldCharacterID)
	}
	if m.addfriend_id != nil {
		fields = append(fields, friendshiphistory.FieldFriendID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case friendshiphistory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case friendshiphistory.FieldCharacterID:
		return m.AddedCharacterID()
	case friendshiphistory.FieldFriendID:
		return m.AddedFriendID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case friendshiphistory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case friendshiphistory.FieldCharacterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCharacterID(v)
		return nil
	case friendshiphistory.FieldFriendID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFriendID(v)
		return nil
	}
	return fmt.Errorf("unknown FriendshipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(friendshiphistory.FieldRef) {
		fields = append(fields, friendshiphistory.FieldRef)
	}
	if m.FieldCleared(friendshiphistory.FieldUpdatedBy) {
		fields = append(fields, friendshiphistory.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipHistoryMutation) ClearField(name string) error {
	switch name {
	case friendshiphistory.FieldRef:
		m.ClearRef()
		return nil
	case friendshiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown FriendshipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipHistoryMutation) ResetField(name string) error {
	switch name {
	case friendshiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case friendshiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case friendshiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case friendshiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case friendshiphistory.FieldRef:
		m.ResetRef()
		return nil
	case friendshiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case friendshiphistory.FieldCharacterID:
		m.ResetCharacterID()
		return nil
	case friendshiphistory.FieldFriendID:
		m.ResetFriendID()
		return nil
	}
	return fmt.Errorf("unknown FriendshipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FriendshipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FriendshipHistory edge %s", name)
}

// ResidenceMutation represents an operation that mutates the Residence nodes in the graph.
type ResidenceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	clearedFields    map[string]struct{}
	occupants        map[int]struct{}
	removedoccupants map[int]struct{}
	clearedoccupants bool
	done             bool
	oldValue         func(context.Context) (*Residence, error)
	predicates       []predicate.Residence
}

var _ ent.Mutation = (*ResidenceMutation)(nil)

// residenceOption allows management of the mutation configuration using functional options.
type residenceOption func(*ResidenceMutation)

// newResidenceMutation creates new mutation for the Residence entity.
func newResidenceMutation(c config, op Op, opts ...residenceOption) *ResidenceMutation {
	m := &ResidenceMutation{
		config:        c,
		op:            op,
		typ:           TypeResidence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResidenceID sets the ID field of the mutation.
func withResidenceID(id uuid.UUID) residenceOption {
	return func(m *ResidenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Residence
		)
		m.oldValue = func(ctx context.Context) (*Residence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Residence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResidence sets the old Residence of the mutation.
func withResidence(node *Residence) residenceOption {
	return func(m *ResidenceMutation) {
		m.oldValue = func(context.Context) (*Residence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResidenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResidenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Residence entities.
func (m *ResidenceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResidenceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResidenceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Residence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResidenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResidenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Residence entity.
// If the Residence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResidenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResidenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResidenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Residence entity.
// If the Residence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResidenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ResidenceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResidenceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Residence entity.
// If the Residence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResidenceMutation) ResetName() {
	m.name = nil
}

// AddOccupantIDs adds the "occupants" edge to the Character entity by ids.
func (m *ResidenceMutation) AddOccupantIDs(ids ...int) {
	if m.occupants == nil {
		m.occupants = make(map[int]struct{})
	}
	for i := range ids {
		m.occupants[ids[i]] = struct{}{}
	}
}

// ClearOccupants clears the "occupants" edge to the Character entity.
func (m *ResidenceMutation) ClearOccupants() {
	m.clearedoccupants = true
}

// OccupantsCleared reports if the "occupants" edge to the Character entity was cleared.
func (m *ResidenceMutation) OccupantsCleared() bool {
	return m.clearedoccupants
}

// RemoveOccupantIDs removes the "occupants" edge to the Character entity by IDs.
func (m *ResidenceMutation) RemoveOccupantIDs(ids ...int) {
	if m.removedoccupants == nil {
		m.removedoccupants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupants, ids[i])
		m.removedoccupants[ids[i]] = struct{}{}
	}
}

// RemovedOccupants returns the removed IDs of the "occupants" edge to the Character entity.
func (m *ResidenceMutation) RemovedOccupantsIDs() (ids []int) {
	for id := range m.removedoccupants {
		ids = append(ids, id)
	}
	return
}

// OccupantsIDs returns the "occupants" edge IDs in the mutation.
func (m *ResidenceMutation) OccupantsIDs() (ids []int) {
	for id := range m.occupants {
		ids = append(ids, id)
	}
	return
}

// ResetOccupants resets all changes to the "occupants" edge.
func (m *ResidenceMutation) ResetOccupants() {
	m.occupants = nil
	m.clearedoccupants = false
	m.removedoccupants = nil
}

// Where appends a list predicates to the ResidenceMutation builder.
func (m *ResidenceMutation) Where(ps ...predicate.Residence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResidenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResidenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Residence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResidenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResidenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Residence).
func (m *ResidenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResidenceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, residence.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, residence.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, residence.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResidenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case residence.FieldCreatedAt:
		return m.CreatedAt()
	case residence.FieldUpdatedAt:
		return m.UpdatedAt()
	case residence.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResidenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case residence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case residence.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case residence.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Residence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResidenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case residence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case residence.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case residence.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Residence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResidenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResidenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResidenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Residence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResidenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResidenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResidenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Residence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResidenceMutation) ResetField(name string) error {
	switch name {
	case residence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case residence.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case residence.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Residence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResidenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.occupants != nil {
		edges = append(edges, residence.EdgeOccupants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResidenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case residence.EdgeOccupants:
		ids := make([]ent.Value, 0, len(m.occupants))
		for id := range m.occupants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResidenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedoccupants != nil {
		edges = append(edges, residence.EdgeOccupants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResidenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case residence.EdgeOccupants:
		ids := make([]ent.Value, 0, len(m.removedoccupants))
		for id := range m.removedoccupants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResidenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoccupants {
		edges = append(edges, residence.EdgeOccupants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResidenceMutation) EdgeCleared(name string) bool {
	switch name {
	case residence.EdgeOccupants:
		return m.clearedoccupants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResidenceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Residence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResidenceMutation) ResetEdge(name string) error {
	switch name {
	case residence.EdgeOccupants:
		m.ResetOccupants()
		return nil
	}
	return fmt.Errorf("unknown Residence edge %s", name)
}

// ResidenceHistoryMutation represents an operation that mutates the ResidenceHistory nodes in the graph.
type ResidenceHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	history_time  *time.Time
	operation     *enthistory.OpType
	ref           *uuid.UUID
	updated_by    *int
	addupdated_by *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ResidenceHistory, error)
	predicates    []predicate.ResidenceHistory
}

var _ ent.Mutation = (*ResidenceHistoryMutation)(nil)

// residencehistoryOption allows management of the mutation configuration using functional options.
type residencehistoryOption func(*ResidenceHistoryMutation)

// newResidenceHistoryMutation creates new mutation for the ResidenceHistory entity.
func newResidenceHistoryMutation(c config, op Op, opts ...residencehistoryOption) *ResidenceHistoryMutation {
	m := &ResidenceHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeResidenceHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResidenceHistoryID sets the ID field of the mutation.
func withResidenceHistoryID(id int) residencehistoryOption {
	return func(m *ResidenceHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ResidenceHistory
		)
		m.oldValue = func(ctx context.Context) (*ResidenceHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResidenceHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResidenceHistory sets the old ResidenceHistory of the mutation.
func withResidenceHistory(node *ResidenceHistory) residencehistoryOption {
	return func(m *ResidenceHistoryMutation) {
		m.oldValue = func(context.Context) (*ResidenceHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResidenceHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResidenceHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResidenceHistory entities.
func (m *ResidenceHistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResidenceHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResidenceHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResidenceHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResidenceHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResidenceHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResidenceHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResidenceHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResidenceHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResidenceHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHistoryTime sets the "history_time" field.
func (m *ResidenceHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ResidenceHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ResidenceHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetOperation sets the "operation" field.
func (m *ResidenceHistoryMutation) SetOperation(et enthistory.OpType) {
	m.operation = &et
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ResidenceHistoryMutation) Operation() (r enthistory.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldOperation(ctx context.Context) (v enthistory.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ResidenceHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetRef sets the "ref" field.
func (m *ResidenceHistoryMutation) SetRef(u uuid.UUID) {
	m.ref = &u
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ResidenceHistoryMutation) Ref() (r uuid.UUID, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldRef(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ResidenceHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[residencehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ResidenceHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[residencehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ResidenceHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, residencehistory.FieldRef)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ResidenceHistoryMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ResidenceHistoryMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldUpdatedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ResidenceHistoryMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ResidenceHistoryMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ResidenceHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[residencehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ResidenceHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[residencehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ResidenceHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, residencehistory.FieldUpdatedBy)
}

// SetName sets the "name" field.
func (m *ResidenceHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResidenceHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResidenceHistory entity.
// If the ResidenceHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResidenceHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ResidenceHistoryMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the ResidenceHistoryMutation builder.
func (m *ResidenceHistoryMutation) Where(ps ...predicate.ResidenceHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResidenceHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResidenceHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResidenceHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResidenceHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResidenceHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResidenceHistory).
func (m *ResidenceHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResidenceHistoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, residencehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, residencehistory.FieldUpdatedAt)
	}
	if m.history_time != nil {
		fields = append(fields, residencehistory.FieldHistoryTime)
	}
	if m.operation != nil {
		fields = append(fields, residencehistory.FieldOperation)
	}
	if m.ref != nil {
		fields = append(fields, residencehistory.FieldRef)
	}
	if m.updated_by != nil {
		fields = append(fields, residencehistory.FieldUpdatedBy)
	}
	if m.name != nil {
		fields = append(fields, residencehistory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResidenceHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case residencehistory.FieldCreatedAt:
		return m.CreatedAt()
	case residencehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case residencehistory.FieldHistoryTime:
		return m.HistoryTime()
	case residencehistory.FieldOperation:
		return m.Operation()
	case residencehistory.FieldRef:
		return m.Ref()
	case residencehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case residencehistory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResidenceHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case residencehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case residencehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case residencehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case residencehistory.FieldOperation:
		return m.OldOperation(ctx)
	case residencehistory.FieldRef:
		return m.OldRef(ctx)
	case residencehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case residencehistory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ResidenceHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResidenceHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case residencehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case residencehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case residencehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case residencehistory.FieldOperation:
		v, ok := value.(enthistory.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case residencehistory.FieldRef:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case residencehistory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case residencehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ResidenceHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResidenceHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, residencehistory.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResidenceHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case residencehistory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResidenceHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case residencehistory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ResidenceHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResidenceHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(residencehistory.FieldRef) {
		fields = append(fields, residencehistory.FieldRef)
	}
	if m.FieldCleared(residencehistory.FieldUpdatedBy) {
		fields = append(fields, residencehistory.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResidenceHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResidenceHistoryMutation) ClearField(name string) error {
	switch name {
	case residencehistory.FieldRef:
		m.ClearRef()
		return nil
	case residencehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown ResidenceHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResidenceHistoryMutation) ResetField(name string) error {
	switch name {
	case residencehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case residencehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case residencehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case residencehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case residencehistory.FieldRef:
		m.ResetRef()
		return nil
	case residencehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case residencehistory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ResidenceHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResidenceHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResidenceHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResidenceHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResidenceHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResidenceHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResidenceHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResidenceHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResidenceHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResidenceHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResidenceHistory edge %s", name)
}
